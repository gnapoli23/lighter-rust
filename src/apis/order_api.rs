/*
 *
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document:
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed errors of method [`account_active_orders`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountActiveOrdersError {
    Status400(models::ResultCode),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`account_inactive_orders`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountInactiveOrdersError {
    Status400(models::ResultCode),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`exchange_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExchangeStatsError {
    Status400(models::ResultCode),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`export`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExportError {
    Status400(models::ResultCode),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`order_book_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrderBookDetailsError {
    Status400(models::ResultCode),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`order_book_orders`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrderBookOrdersError {
    Status400(models::ResultCode),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`order_books`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrderBooksError {
    Status400(models::ResultCode),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`recent_trades`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RecentTradesError {
    Status400(models::ResultCode),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trades`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TradesError {
    Status400(models::ResultCode),
    UnknownValue(serde_json::Value),
}

/// Get account active orders. `auth` can be generated using the SDK.
pub async fn account_active_orders(
    configuration: &configuration::Configuration,
    account_index: i64,
    market_id: i32,
    authorization: Option<&str>,
    auth: Option<&str>,
) -> Result<models::Orders, Error<AccountActiveOrdersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_index = account_index;
    let p_query_market_id = market_id;
    let p_header_authorization = authorization;
    let p_query_auth = auth;

    let uri_str = format!("{}/api/v1/accountActiveOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("account_index", &p_query_account_index.to_string())]);
    req_builder = req_builder.query(&[("market_id", &p_query_market_id.to_string())]);
    if let Some(ref param_value) = p_query_auth {
        req_builder = req_builder.query(&[("auth", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_authorization {
        req_builder = req_builder.header("authorization", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Orders`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Orders`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountActiveOrdersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get account inactive orders
pub async fn account_inactive_orders(
    configuration: &configuration::Configuration,
    account_index: i64,
    limit: i64,
    authorization: Option<&str>,
    auth: Option<&str>,
    market_id: Option<i32>,
    ask_filter: Option<i32>,
    between_timestamps: Option<&str>,
    cursor: Option<&str>,
) -> Result<models::Orders, Error<AccountInactiveOrdersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_index = account_index;
    let p_query_limit = limit;
    let p_header_authorization = authorization;
    let p_query_auth = auth;
    let p_query_market_id = market_id;
    let p_query_ask_filter = ask_filter;
    let p_query_between_timestamps = between_timestamps;
    let p_query_cursor = cursor;

    let uri_str = format!("{}/api/v1/accountInactiveOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_auth {
        req_builder = req_builder.query(&[("auth", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("account_index", &p_query_account_index.to_string())]);
    if let Some(ref param_value) = p_query_market_id {
        req_builder = req_builder.query(&[("market_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ask_filter {
        req_builder = req_builder.query(&[("ask_filter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_between_timestamps {
        req_builder = req_builder.query(&[("between_timestamps", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cursor {
        req_builder = req_builder.query(&[("cursor", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("limit", &p_query_limit.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_authorization {
        req_builder = req_builder.header("authorization", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Orders`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Orders`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountInactiveOrdersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get exchange stats
pub async fn exchange_stats(
    configuration: &configuration::Configuration,
) -> Result<models::ExchangeStats, Error<ExchangeStatsError>> {
    let uri_str = format!("{}/api/v1/exchangeStats", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ExchangeStats`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ExchangeStats`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ExchangeStatsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Export data
pub async fn export(
    configuration: &configuration::Configuration,
    r#type: &str,
    authorization: Option<&str>,
    auth: Option<&str>,
    account_index: Option<i64>,
    market_id: Option<i32>,
) -> Result<models::ExportData, Error<ExportError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_type = r#type;
    let p_header_authorization = authorization;
    let p_query_auth = auth;
    let p_query_account_index = account_index;
    let p_query_market_id = market_id;

    let uri_str = format!("{}/api/v1/export", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_auth {
        req_builder = req_builder.query(&[("auth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_index {
        req_builder = req_builder.query(&[("account_index", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_market_id {
        req_builder = req_builder.query(&[("market_id", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("type", &p_query_type.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_authorization {
        req_builder = req_builder.header("authorization", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ExportData`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ExportData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ExportError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get order books metadata
pub async fn order_book_details(
    configuration: &configuration::Configuration,
    market_id: Option<i32>,
) -> Result<models::OrderBookDetails, Error<OrderBookDetailsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_market_id = market_id;

    let uri_str = format!("{}/api/v1/orderBookDetails", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_market_id {
        req_builder = req_builder.query(&[("market_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrderBookDetails`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrderBookDetails`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrderBookDetailsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get order book orders
pub async fn order_book_orders(
    configuration: &configuration::Configuration,
    market_id: i32,
    limit: i64,
) -> Result<models::OrderBookOrders, Error<OrderBookOrdersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_market_id = market_id;
    let p_query_limit = limit;

    let uri_str = format!("{}/api/v1/orderBookOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("market_id", &p_query_market_id.to_string())]);
    req_builder = req_builder.query(&[("limit", &p_query_limit.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrderBookOrders`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrderBookOrders`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrderBookOrdersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get order books metadata.<hr>**Response Description:**<br><br>1) **Taker and maker fees** are in percentage.<br>2) **Min base amount:** The amount of base token that can be traded in a single order.<br>3) **Min quote amount:** The amount of quote token that can be traded in a single order.<br>4) **Supported size decimals:** The number of decimal places that can be used for the size of the order.<br>5) **Supported price decimals:** The number of decimal places that can be used for the price of the order.<br>6) **Supported quote decimals:** Size Decimals + Quote Decimals.
pub async fn order_books(
    configuration: &configuration::Configuration,
    market_id: Option<i32>,
) -> Result<models::OrderBooks, Error<OrderBooksError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_market_id = market_id;

    let uri_str = format!("{}/api/v1/orderBooks", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_market_id {
        req_builder = req_builder.query(&[("market_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrderBooks`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrderBooks`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrderBooksError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get recent trades
pub async fn recent_trades(
    configuration: &configuration::Configuration,
    market_id: i32,
    limit: i64,
) -> Result<models::Trades, Error<RecentTradesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_market_id = market_id;
    let p_query_limit = limit;

    let uri_str = format!("{}/api/v1/recentTrades", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("market_id", &p_query_market_id.to_string())]);
    req_builder = req_builder.query(&[("limit", &p_query_limit.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Trades`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Trades`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RecentTradesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get trades
pub async fn trades(
    configuration: &configuration::Configuration,
    sort_by: &str,
    limit: i64,
    authorization: Option<&str>,
    auth: Option<&str>,
    market_id: Option<i32>,
    account_index: Option<i64>,
    order_index: Option<i64>,
    sort_dir: Option<&str>,
    cursor: Option<&str>,
    from: Option<i64>,
    ask_filter: Option<i32>,
) -> Result<models::Trades, Error<TradesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_sort_by = sort_by;
    let p_query_limit = limit;
    let p_header_authorization = authorization;
    let p_query_auth = auth;
    let p_query_market_id = market_id;
    let p_query_account_index = account_index;
    let p_query_order_index = order_index;
    let p_query_sort_dir = sort_dir;
    let p_query_cursor = cursor;
    let p_query_from = from;
    let p_query_ask_filter = ask_filter;

    let uri_str = format!("{}/api/v1/trades", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_auth {
        req_builder = req_builder.query(&[("auth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_market_id {
        req_builder = req_builder.query(&[("market_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_index {
        req_builder = req_builder.query(&[("account_index", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order_index {
        req_builder = req_builder.query(&[("order_index", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("sort_by", &p_query_sort_by.to_string())]);
    if let Some(ref param_value) = p_query_sort_dir {
        req_builder = req_builder.query(&[("sort_dir", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cursor {
        req_builder = req_builder.query(&[("cursor", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_from {
        req_builder = req_builder.query(&[("from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ask_filter {
        req_builder = req_builder.query(&[("ask_filter", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("limit", &p_query_limit.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_authorization {
        req_builder = req_builder.header("authorization", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Trades`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Trades`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TradesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
