/*
 *
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document:
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed errors of method [`account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountError {
    Status400(models::ResultCode),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`account_limits`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountLimitsError {
    Status400(models::ResultCode),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`account_metadata`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountMetadataError {
    Status400(models::ResultCode),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_by_l1_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsByL1AddressError {
    Status400(models::ResultCode),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`apikeys`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApikeysError {
    Status400(models::ResultCode),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`change_account_tier`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangeAccountTierError {
    Status400(models::ResultCode),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`l1_metadata`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum L1MetadataError {
    Status400(models::ResultCode),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`liquidations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LiquidationsError {
    Status400(models::ResultCode),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pnl`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PnlError {
    Status400(models::ResultCode),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`position_funding`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PositionFundingError {
    Status400(models::ResultCode),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`public_pools`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PublicPoolsError {
    Status400(models::ResultCode),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`public_pools_metadata`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PublicPoolsMetadataError {
    Status400(models::ResultCode),
    UnknownValue(serde_json::Value),
}

/// Get account by account's index. <br>More details about account index: [Account Index](https://apidocs.lighter.xyz/docs/account-index)<hr>**Response Description:**<br><br>1) **Status:** 1 is active 0 is inactive.<br>2) **Collateral:** The amount of collateral in the account.<hr>**Position Details Description:**<br>1) **OOC:** Open order count in that market.<br>2) **Sign:** 1 for Long, -1 for Short.<br>3) **Position:** The amount of position in that market.<br>4) **Avg Entry Price:** The average entry price of the position.<br>5) **Position Value:** The value of the position.<br>6) **Unrealized PnL:** The unrealized profit and loss of the position.<br>7) **Realized PnL:** The realized profit and loss of the position.
pub async fn account(
    configuration: &configuration::Configuration,
    by: &str,
    value: &str,
) -> Result<models::DetailedAccounts, Error<AccountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_by = by;
    let p_query_value = value;

    let uri_str = format!("{}/api/v1/account", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("by", &p_query_by.to_string())]);
    req_builder = req_builder.query(&[("value", &p_query_value.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DetailedAccounts`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DetailedAccounts`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get account limits
pub async fn account_limits(
    configuration: &configuration::Configuration,
    account_index: i64,
    authorization: Option<&str>,
    auth: Option<&str>,
) -> Result<models::AccountLimits, Error<AccountLimitsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_index = account_index;
    let p_header_authorization = authorization;
    let p_query_auth = auth;

    let uri_str = format!("{}/api/v1/accountLimits", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("account_index", &p_query_account_index.to_string())]);
    if let Some(ref param_value) = p_query_auth {
        req_builder = req_builder.query(&[("auth", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_authorization {
        req_builder = req_builder.header("authorization", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountLimits`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountLimits`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountLimitsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get account metadatas
pub async fn account_metadata(
    configuration: &configuration::Configuration,
    by: &str,
    value: &str,
    authorization: Option<&str>,
    auth: Option<&str>,
) -> Result<models::AccountMetadatas, Error<AccountMetadataError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_by = by;
    let p_query_value = value;
    let p_header_authorization = authorization;
    let p_query_auth = auth;

    let uri_str = format!("{}/api/v1/accountMetadata", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("by", &p_query_by.to_string())]);
    req_builder = req_builder.query(&[("value", &p_query_value.to_string())]);
    if let Some(ref param_value) = p_query_auth {
        req_builder = req_builder.query(&[("auth", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_authorization {
        req_builder = req_builder.header("authorization", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountMetadatas`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountMetadatas`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountMetadataError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get accounts by l1_address returns all accounts associated with the given L1 address
pub async fn accounts_by_l1_address(
    configuration: &configuration::Configuration,
    l1_address: &str,
) -> Result<models::SubAccounts, Error<AccountsByL1AddressError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_l1_address = l1_address;

    let uri_str = format!("{}/api/v1/accountsByL1Address", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("l1_address", &p_query_l1_address.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SubAccounts`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SubAccounts`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsByL1AddressError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get account api key. Set `api_key_index` to 255 to retrieve all api keys associated with the account.
pub async fn apikeys(
    configuration: &configuration::Configuration,
    account_index: i64,
    api_key_index: Option<i32>,
) -> Result<models::AccountApiKeys, Error<ApikeysError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_index = account_index;
    let p_query_api_key_index = api_key_index;

    let uri_str = format!("{}/api/v1/apikeys", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("account_index", &p_query_account_index.to_string())]);
    if let Some(ref param_value) = p_query_api_key_index {
        req_builder = req_builder.query(&[("api_key_index", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountApiKeys`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountApiKeys`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApikeysError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Change account tier
pub async fn change_account_tier(
    configuration: &configuration::Configuration,
    account_index: i64,
    new_tier: &str,
    authorization: Option<&str>,
    auth: Option<&str>,
) -> Result<models::RespChangeAccountTier, Error<ChangeAccountTierError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_form_account_index = account_index;
    let p_form_new_tier = new_tier;
    let p_header_authorization = authorization;
    let p_form_auth = auth;

    let uri_str = format!("{}/api/v1/changeAccountTier", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_authorization {
        req_builder = req_builder.header("authorization", param_value.to_string());
    }
    let mut multipart_form = reqwest::multipart::Form::new();
    if let Some(param_value) = p_form_auth {
        multipart_form = multipart_form.text("auth", param_value.to_string());
    }
    multipart_form = multipart_form.text("account_index", p_form_account_index.to_string());
    multipart_form = multipart_form.text("new_tier", p_form_new_tier.to_string());
    req_builder = req_builder.multipart(multipart_form);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespChangeAccountTier`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespChangeAccountTier`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ChangeAccountTierError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get L1 metadata
pub async fn l1_metadata(
    configuration: &configuration::Configuration,
    l1_address: &str,
    authorization: Option<&str>,
    auth: Option<&str>,
) -> Result<models::L1Metadata, Error<L1MetadataError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_l1_address = l1_address;
    let p_header_authorization = authorization;
    let p_query_auth = auth;

    let uri_str = format!("{}/api/v1/l1Metadata", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_auth {
        req_builder = req_builder.query(&[("auth", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("l1_address", &p_query_l1_address.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_authorization {
        req_builder = req_builder.header("authorization", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::L1Metadata`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::L1Metadata`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<L1MetadataError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get liquidation infos
pub async fn liquidations(
    configuration: &configuration::Configuration,
    account_index: i64,
    limit: i64,
    authorization: Option<&str>,
    auth: Option<&str>,
    market_id: Option<i32>,
    cursor: Option<&str>,
) -> Result<models::LiquidationInfos, Error<LiquidationsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_index = account_index;
    let p_query_limit = limit;
    let p_header_authorization = authorization;
    let p_query_auth = auth;
    let p_query_market_id = market_id;
    let p_query_cursor = cursor;

    let uri_str = format!("{}/api/v1/liquidations", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_auth {
        req_builder = req_builder.query(&[("auth", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("account_index", &p_query_account_index.to_string())]);
    if let Some(ref param_value) = p_query_market_id {
        req_builder = req_builder.query(&[("market_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cursor {
        req_builder = req_builder.query(&[("cursor", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("limit", &p_query_limit.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_authorization {
        req_builder = req_builder.header("authorization", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LiquidationInfos`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LiquidationInfos`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LiquidationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get account PnL chart
pub async fn pnl(
    configuration: &configuration::Configuration,
    by: &str,
    value: &str,
    resolution: &str,
    start_timestamp: i64,
    end_timestamp: i64,
    count_back: i64,
    authorization: Option<&str>,
    auth: Option<&str>,
    ignore_transfers: Option<bool>,
) -> Result<models::AccountPnL, Error<PnlError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_by = by;
    let p_query_value = value;
    let p_query_resolution = resolution;
    let p_query_start_timestamp = start_timestamp;
    let p_query_end_timestamp = end_timestamp;
    let p_query_count_back = count_back;
    let p_header_authorization = authorization;
    let p_query_auth = auth;
    let p_query_ignore_transfers = ignore_transfers;

    let uri_str = format!("{}/api/v1/pnl", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_auth {
        req_builder = req_builder.query(&[("auth", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("by", &p_query_by.to_string())]);
    req_builder = req_builder.query(&[("value", &p_query_value.to_string())]);
    req_builder = req_builder.query(&[("resolution", &p_query_resolution.to_string())]);
    req_builder = req_builder.query(&[("start_timestamp", &p_query_start_timestamp.to_string())]);
    req_builder = req_builder.query(&[("end_timestamp", &p_query_end_timestamp.to_string())]);
    req_builder = req_builder.query(&[("count_back", &p_query_count_back.to_string())]);
    if let Some(ref param_value) = p_query_ignore_transfers {
        req_builder = req_builder.query(&[("ignore_transfers", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_authorization {
        req_builder = req_builder.header("authorization", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountPnL`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountPnL`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PnlError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get accounts position fundings
pub async fn position_funding(
    configuration: &configuration::Configuration,
    account_index: i64,
    limit: i64,
    authorization: Option<&str>,
    auth: Option<&str>,
    market_id: Option<i32>,
    cursor: Option<&str>,
    side: Option<&str>,
) -> Result<models::PositionFundings, Error<PositionFundingError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_index = account_index;
    let p_query_limit = limit;
    let p_header_authorization = authorization;
    let p_query_auth = auth;
    let p_query_market_id = market_id;
    let p_query_cursor = cursor;
    let p_query_side = side;

    let uri_str = format!("{}/api/v1/positionFunding", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_auth {
        req_builder = req_builder.query(&[("auth", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("account_index", &p_query_account_index.to_string())]);
    if let Some(ref param_value) = p_query_market_id {
        req_builder = req_builder.query(&[("market_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cursor {
        req_builder = req_builder.query(&[("cursor", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("limit", &p_query_limit.to_string())]);
    if let Some(ref param_value) = p_query_side {
        req_builder = req_builder.query(&[("side", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_authorization {
        req_builder = req_builder.header("authorization", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PositionFundings`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PositionFundings`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PositionFundingError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get public pools
pub async fn public_pools(
    configuration: &configuration::Configuration,
    index: i64,
    limit: i64,
    authorization: Option<&str>,
    auth: Option<&str>,
    filter: Option<&str>,
    account_index: Option<i64>,
) -> Result<models::PublicPools, Error<PublicPoolsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_index = index;
    let p_query_limit = limit;
    let p_header_authorization = authorization;
    let p_query_auth = auth;
    let p_query_filter = filter;
    let p_query_account_index = account_index;

    let uri_str = format!("{}/api/v1/publicPools", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_auth {
        req_builder = req_builder.query(&[("auth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter {
        req_builder = req_builder.query(&[("filter", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("index", &p_query_index.to_string())]);
    req_builder = req_builder.query(&[("limit", &p_query_limit.to_string())]);
    if let Some(ref param_value) = p_query_account_index {
        req_builder = req_builder.query(&[("account_index", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_authorization {
        req_builder = req_builder.header("authorization", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PublicPools`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PublicPools`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PublicPoolsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get public pools metadata
pub async fn public_pools_metadata(
    configuration: &configuration::Configuration,
    index: i64,
    limit: i64,
    authorization: Option<&str>,
    auth: Option<&str>,
    filter: Option<&str>,
    account_index: Option<i64>,
) -> Result<models::RespPublicPoolsMetadata, Error<PublicPoolsMetadataError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_index = index;
    let p_query_limit = limit;
    let p_header_authorization = authorization;
    let p_query_auth = auth;
    let p_query_filter = filter;
    let p_query_account_index = account_index;

    let uri_str = format!("{}/api/v1/publicPoolsMetadata", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_auth {
        req_builder = req_builder.query(&[("auth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter {
        req_builder = req_builder.query(&[("filter", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("index", &p_query_index.to_string())]);
    req_builder = req_builder.query(&[("limit", &p_query_limit.to_string())]);
    if let Some(ref param_value) = p_query_account_index {
        req_builder = req_builder.query(&[("account_index", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_authorization {
        req_builder = req_builder.header("authorization", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RespPublicPoolsMetadata`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RespPublicPoolsMetadata`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PublicPoolsMetadataError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
